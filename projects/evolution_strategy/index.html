<!DOCTYPE html>
<html style="font-size: 16px;">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Evolution strategy. Unknown parameters estimation">
    <meta name="description" content="Project overview page">
<<<<<<< HEAD
    <title>Evolution Strategy</title>
=======
    <title>Ant Colony System</title>
>>>>>>> 7169d9ccda817c6b94d244f0627b2f5b6c3b1034
    <link rel="stylesheet" href="themes/nicepage.css" media="screen">
    <link rel="stylesheet" href="themes/project.css" media="screen">
    <link rel="stylesheet" href="themes/prism.css" media="screen">
    <meta name="theme-color" content="#478ac9">
    <link id="u-theme-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i|Open+Sans:300,300i,400,400i,600,600i,700,700i,800,800i">
  </head>
  <body class="u-body">
    <div class="content">
      <section class="u-clearfix u-grey-5 u-section-1" id="sec-2488">
        <div class="u-clearfix u-sheet u-sheet-1">
          <div class="u-clearfix u-expanded-width u-gutter-10 u-layout-wrap u-layout-wrap-1">
            <div class="u-gutter-0 u-layout">
              <div class="u-layout-row">
                <div class="u-container-style u-layout-cell u-size-30 u-layout-cell-1">
                  <div class="u-container-layout u-valign-middle u-container-layout-1">
                    <h2 class="u-align-center u-text u-text-1">Evolution strategy. Unknown parameters estimation</h2>
<<<<<<< HEAD
                    <p class="u-align-justify u-text u-text-2">In the class of evolutionary algorithms, there is a method called evolution strategy dating back to early 1960s. The core ideas of this technique are (1) candidates for solutions should only mutate in a mutation windows, and (2) we only take the best candidates from offspring combined with the parents population. In our case, we are given a measured signal coming from a known function with unknown parameters, and we need to determine their numerical value so that the imported data is well approximated by the given function. Thus, every solution candidate is a vector of estimated parameters <i>and</i> respective mutation steps.<br><br>
=======
                    <p class="u-align-justify u-text u-text-2">Evolution strategy is... virtually impossible to brute-force. Whether finding the minimal distance through all cities, scheduling jobs on machines or packing a knapsack, there is no straight-forward approach. These problems are NP-hard. To solve some of them one may use ant colony optimization, a stochastic technique inspired by the behavior of ants, i.e. pheromone secretion on common paths. This project utilizes an ant colony system constrained to given points on a plane, in order to find the shortest path that visits all of them exactly once.<br><br>
>>>>>>> 7169d9ccda817c6b94d244f0627b2f5b6c3b1034
                    Visit the project repository <a href="https://github.com/rol-x/evolution_strategy">here!</a></p>
                  </div>
                </div>
                <div class="u-container-style u-layout-cell u-size-30 u-layout-cell-2">
                  <div class="u-container-layout u-valign-middle-md u-valign-middle-xl u-container-layout-2" src="">
<<<<<<< HEAD
                    <img class="u-expanded-width-xs u-image u-preserve-proportions u-image-1" src="images/est.png">
=======
                    <img class="u-expanded-width-xs u-image u-preserve-proportions u-image-1" src="images/ant_system.png" data-image-width="598" data-image-height="482">
>>>>>>> 7169d9ccda817c6b94d244f0627b2f5b6c3b1034
                  </div>
                </div>
              </div>
              <hr>
              <div style="margin: 50px"></div>
              <div class="u-layout-row" style="width: 100%">
                <div style="text-align: justify"><br>
<<<<<<< HEAD
                  <div class="problem">
                  Given a function of form <i>y(x) = ax&sup2; + b</i>cos(<i>c&pi;x</i>) and a set of (<i>x</i>, <i>y</i>) pairs, find the coefficients <i>a</i>, <i>b</i> and <i>c</i>, so that the function <i>y</i> closely approximates the input data within set error marigin.
                </div>
                    <div style="margin: 50px"></div>
                <div style="float: right; width: 55%; padding: 5px; margin: 10px 0px 20px 40px;">
                  <img class="u-preserve-proportions" style="width: 100%" src="images/input.png">
                </div><br><br><br><br><br>

                  To create the population, we need a random set of candidates and mutation factors. The initial guesses are selected from a potentially good interval, i.e. normal distribution with <i>&sigma; = 5</i> bound between -10 and 10. While the wanted parameters evolve with the help of mutation factors, the mutation factors themselves are log-normal with coefficients &tau;<sub>1</sub>; and &tau;<sub>2</sub>.
=======
                  The problem is to determine the shortest path going through every city given by coordinates, like this:
                  <pre>x = [3 2 12 7 9 3 16 11 9 2];      y = [1 4 2 4.5 9 1.5 11 8 10 7];
                    </pre>
                    <div style="margin: 50px"></div>
                <div style="float: right; width: 55%; padding: 5px; margin: 10px 0px 20px 40px;">
                  <img class="u-preserve-proportions" style="width: 100%" src="images/cities.png">
                </div><br><br><br><br>

                   First, the distances are calculated and equal trace of pheromone is placed on every path between the cities. Then, <b>ants_count</b> ants are created, with a boolean vector of visited cities and two variables, storing tour length and current city (visible below). Each ant is also assigned a value in a dictionary <b>tours</b>, corresponding to the cities it traveled to on its tour, in order. A random selection of starting points is performed for our ants, which will remain their starting points throughout the algorithm, hence the name <b>hometowns</b>.
>>>>>>> 7169d9ccda817c6b94d244f0627b2f5b6c3b1034
                  </div>
                  <div style="margin: 50px"></div>
                  <div style="text-align: justify">
                    <div style="float: left; width: 55%; padding: 5px; margin: 0px 50px 30px 0px;">
<<<<<<< HEAD
                      <img class="u-preserve-proportions" style="width: 100%" src="images/est_err.png">
                    </div><br><br>
                   In every iteration of the algorithm an offspring population is generated from parents thorugh mutation. The two groups are then combined and their fit to the input data is assessed. Only the best candidates are selected from this set and this is considered the parents population in the next iteration. The loop finishes when the difference between the best parent and the best offspring is smaller than given accuracy &eps;. Finally, the parameters are acquired from the best candidate in the final population and the resulting function is plotted against the input data. Additionally, the differences between the real and estimated values are shown on a graph.

                 </div>
=======
                      <img class="u-preserve-proportions" style="width: 100%" src="images/a.png">
                    </div><br>
                   Each ant then chooses the next city to go to, based on the amount of pheromone on feasible paths and the distance. Probability of choosing city <b>j</b> is given by the <b>j</b>-th column in the decision table <b>a</b>, where indices represent ants. When each ant visits all <b>N</b> cities, the pheromones of the best ants are deposited on appropriate paths and our cybernetic insects start the tour again, until they perform set amount of tours.

                 </div>
                 <div style="margin: 50px"></div>
                   <div style="text-align: justify">
                     <div style="float: right; width: 55%; padding: 5px; margin: 10px 0px 20px 40px;">
                       <img class="u-preserve-proportions" style="width: 100%" src="images/result.png">
                     </div><br><br><br>
                    After each iteration, the shortest path is evaluated, and the optimal path is selected from all the tours. The results are presented on a graph, representing the map of considered cities, with gray connections being the amount of pheromones squared, and the green line being the optimal path (figures below). A preview of the shortest path in each tour is available, together with the percentage of the ants that took it. The optimal path and its length are then printed out. For <b>ants_count</b> = 20 the optimal solution is more frequent towards the final tours and the less ants are allowed to leave the pheromone, the higher likelihood of getting stuck on a suboptimal path.

              </div>
>>>>>>> 7169d9ccda817c6b94d244f0627b2f5b6c3b1034
            </div>
            <div style="margin: 50px"></div>
            <hr>
            <div style="margin: 50px"></div>
          </div>
        </div>
      </section>
      <div class="flex-container">
        <div class="flex-left">
          <pre class="line-numbers">
<<<<<<< HEAD
            <code class="language-python">"""Implementation of evolution strategy for gray box coefficient estimation."""
            import numpy as np
            import numpy.random as rnd
            import matplotlib.pyplot as plt


            def f(a, b, c, x):
                """Return the value of the function to be estimated (the gray box)."""
                return a*x**2 + b*np.cos(c*x*np.pi)


            def initial_x():
                """Return the vector of initial estimated coefficient."""
                a = min(max(rnd.randn()*5, -10), 10)
                b = min(max(rnd.randn()*5, -10), 10)
                c = min(max(rnd.randn()*5, -10), 10)
                return [a, b, c]


            def initial_sigma():
                """Return the vector of initial mutation factors."""
                s_a = rnd.randn()
                s_b = rnd.randn()
                s_c = rnd.randn()
                return [s_a, s_b, s_c]


            class Population:
                """Class for managing the evolving population."""

                def __init__(self, pop_size=100, mutations_count=5):
                    """Initialize a population and neccessary inner values."""
                    # The population holding vectors of solutions and their mutations
                    self.population = [initial_x() + initial_sigma()
                                       for i in range(pop_size)]
                    # The maximal size of the population
                    self.pop_size = pop_size
                    # The amount of offspring each parent has
                    self.mutations_count = mutations_count
                    # Mutations coefficients
                    self.tau_1 = 1/np.sqrt(2*pop_size)
                    self.tau_2 = 1/np.sqrt(2*np.sqrt(pop_size))

                def load_data(self, dataset_num):
                    """Load x and y data from the sspecified dataset."""
                    data = np.loadtxt('./data/ES_data_' + str(dataset_num) + '.dat')
                    self.data_x = [datapoint[0] for datapoint in data]
                    self.data_y = [datapoint[1] for datapoint in data]

                def mutate(self):
                    """Produce offspring for every vector in population."""
                    offspring = []
                    for mutation in range(self.mutations_count):
                        mutated = []
                        for i in range(self.pop_size):
                            # Calculate first mutation-changing coefficient
                            rnd_tau = rnd.randn() * self.tau_1
                            # Get a vector of target values and their mutations
                            v = np.array(self.population[i])
                            # Update target values using their mutations
                            a = v[0] + rnd.randn() * v[3]
                            b = v[1] + rnd.randn() * v[4]
                            c = v[2] + rnd.randn() * v[5]
                            # Update mutations using mutation coefficients
                            s_a = v[3] * np.exp(rnd_tau) * np.exp(rnd.randn()*self.tau_2)
                            s_b = v[4] * np.exp(rnd_tau) * np.exp(rnd.randn()*self.tau_2)
                            s_c = v[5] * np.exp(rnd_tau) * np.exp(rnd.randn()*self.tau_2)
                            # Add each newly created vector to the mutated population
                            mutated.append([a, b, c, s_a, s_b, s_c])
                        # Combine the mutated populations and return them as the offspring
                        offspring += mutated
                    return offspring

                def evaluate(self, group, best=False, indices=False):
                    """Return a dictionary of vector indices and theirs errors in order."""
                    # Create and populate the dictionary
                    error = {}
                    for i in range(len(group)):
                        v = np.array(group[i])
                        estimated_y = [f(v[0], v[1], v[2], x) for x in self.data_x]
                        error[i] = np.sum([(estimated_y[i] - self.data_y[i])**2
                                          for i in range(len(self.data_y))])
                    # Sort the dictionary by values
                    error = {index: error for (index, error) in sorted(error.items(),
                             key=lambda pair: pair[1])}
                    if best:
                        return list(error.values())[0]
                    if indices:
                        return list(error.keys())
                    return error

                def plot_results(self, a, b, c):
                    """Plot estimated and measured values."""
                    estimated_y = [f(a, b, c, x) for x in self.data_x]
                    errors = [estimated_y[i] - self.data_y[i]
                              for i in range(len(self.data_y))]

                    #  Plot the data and estimated function on one plot
                    plt.figure(figsize=(12, 8))
                    plt.plot(self.data_x, self.data_y, color='darkblue')
                    plt.plot(self.data_x, estimated_y, color='magenta')
                    if b < 0:
                        plt.legend(['Imported data', f'Function {round(a, 2)}x^2 '
                                    + f'{round(b, 2)}cos({round(c, 2)}pi x)'])
                    else:
                        plt.legend(['Imported data', f'Function {round(a, 2)}x^2 + '
                                    + f'{round(b, 2)}cos({round(c, 2)}pi x)'])
                    plt.title('Estimated function vs imported data')
                    plt.show()

                    # Plot estimation errors
                    plt.figure(figsize=(12, 8))
                    plt.plot(self.data_x, errors, color='pink')
                    plt.plot(self.data_x, [np.mean(list(map(abs, errors)))
                                           for _ in self.data_x], color='lightblue')
                    plt.legend(['Estimation error', 'Average absolute estimation error'])
                    plt.title('Data estimation error')
                    plt.show()
=======
            <code class="language-python">"""
            Implementation of Ant Colony System for the travelling salesman problem.

            We are given a map containing 10 cities on 2d plane. In order to find the
            shortest path that goes through all of them we utilize simulated ants,
            depositing pheromones in greater amount on shorter paths and then choosing
            the paths with more pheromone on them. The ants also have a memory of the
            visited cities, otherwise it's just a stochastic process.
            """
            import math
            import random as rnd
            import pandas as pd
            import matplotlib.pyplot as plt


            class AntColonySystem:
                """Class handling ants and map creation, iterations and more."""

                def __init__(self, ants_count, alpha=1, beta=5, rho=0.5, tau_0=0.1):
                    """
                    Create a simulation object by specifying needed parameters.

                    m - the number of ants
                    alpha, beta - decision coefficients (pheromone and distance)
                    rho - pheromone evaporation coefficient
                    tau_0 - initial pheromone amount
                    """
                    self.ants_count = ants_count
                    self.alpha = alpha
                    self.beta = beta
                    self.rho = rho
                    self.tau_0 = tau_0

                def open_map(self, map_id):
                    """Use the provided data file to import the coordinates of cities."""
                    self.map_id = map_id
                    cities = open(f'data/AS_map_{map_id}.txt')
                    for line in cities:
                        line = line.strip()
                        if line[0] == 'x':
                            self.x = list(map(float, line[5:-2].split()))
                        if line[0] == 'y':
                            self.y = list(map(float, line[5:-2].split()))

                    # Check validity of coordinates in the file
                    if len(self.x) != len(self.y):
                        raise SystemExit("Cities coordinates invalid")
                    self.N = len(self.x)
                    return self.N

                def prepare_distance_table(self):
                    """Calculate the euclidean distance between each two cities."""
                    self.d = pd.DataFrame(data=self.tau_0, index=range(1, self.N+1),
                                          columns=range(1, self.N+1))
                    for city_1 in self.d:
                        self.d[city_1] = [self.distance(city_1, city_2)
                                          for city_2 in self.d.index]

                def prepare_pheromone_table(self):
                    """Calculate the amount of pheromone between each two cities."""
                    self.tau = pd.DataFrame(data=self.tau_0, index=range(1, self.N+1),
                                            columns=range(1, self.N+1))
                    for i in self.tau.index:
                        self.tau.loc[i, i] = 0

                def set_hometowns(self):
                    """Create a list of fixed starting points for each ant."""
                    self.hometowns = [rnd.randint(1, self.N)
                                      for _ in range(ant_colony.ants_count)]

                def spawn_ants(self):
                    """Create a table of ants, with a record of visited cities."""
                    self.ants = pd.DataFrame(data=False, index=range(self.ants_count),
                                             columns=range(1, self.N+1))
                    self.ants['Current'] = self.hometowns
                    self.ants['TourLength'] = 0.0
                    for ant in self.ants.index:
                        self.ants.loc[ant, self.ants.loc[ant, 'Current']] = True

                def draw_map(self):
                    """Draw a map of the cities."""
                    self.fig, self.ax = plt.subplots()
                    self.fig.set_size_inches(12, 9)
                    self.ax.plot(self.x, self.y, 'bo', ms=4)
                    self.ax.set_title(f'Cities in map {self.map_id}')
                    for i in range(0, self.N):
                        self.ax.annotate(i+1, (self.x[i]+0.12, self.y[i]), fontsize=14)

                def ants_tour_complete(self):
                    """Return whether all ants visited all the cities."""
                    return (self.ants.xs(range(1, self.N+1), axis=1).all()).all()

                def calculate_decision_table(self):
                    """Calculate a decision table with probability of taking each path."""
                    # Probability proportional to pheromone amount over distance
                    a_naive = (self.tau**self.alpha/self.d**self.beta).fillna(0)
                    # Dividing probabilities by the sum of eligible neighbours
                    self.a = pd.DataFrame(index=self.ants.index, columns=a_naive.columns)
                    for ant in self.ants.index:
                        current = self.ants.loc[ant, 'Current']
                        neighbourhood = sum(a_naive[current]
                                            * ~self.ants.loc[ant][:self.N])
                        self.a.loc[ant] = ((a_naive[current] / neighbourhood)
                                           * ~self.ants.loc[ant][:self.N])

                def choose_next_cities(self):
                    """Return a series of next moves for each ant."""
                    next_cities = pd.Series(index=self.ants.index, data=0)
                    for ant in self.a.index:
                        preferred = pd.to_numeric(self.a.loc[ant]).fillna(0)
                        its_my_goddamn_choice = rnd.random()
                        while(len(preferred) > 0):
                            best_city = preferred.idxmax()
                            if (its_my_goddamn_choice <= preferred[best_city]):
                                next_cities.loc[ant] = best_city
                                break
                            else:
                                its_my_goddamn_choice -= preferred[best_city]
                                preferred.drop(best_city, inplace=True)
                    return next_cities

                def finish_in_hometowns(self):
                    """Add a final path to the tour, from current city to hometown."""
                    for ant in self.ants.index:
                        current = self.ants.loc[ant, 'Current']
                        self.ants.loc[ant, 'TourLength'] += self.distance(
                                                            current, self.hometowns[ant])
                        self.draw_path(current, self.hometowns[ant], 'grey',
                                       self.tau.at[current, self.hometowns[ant]])
                        self.ants.loc[ant, 'Current'] = self.hometowns[ant]

                def update_pheromones(self, tours, elite_ants_count=4):
                    """Evaporate some of the existing pheromones and deposit new."""
                    # Evaporte some of the pheromone
                    self.tau *= (1 - self.rho)
                    # Store best N ants in a dictionary with their tour lengths
                    elite_ants = {ant: self.ants.loc[ant, 'TourLength'] for ant in tours}
                    elite_ants = dict(sorted(elite_ants.items(), key=lambda ant: ant[1]))
                    elite_ants = list(elite_ants.items())[:elite_ants_count]
                    # Add pheronome only on the elite ants paths
                    for ant, best_length in elite_ants:
                        for city in range(self.N):
                            self.tau.at[tours[ant][city], tours[ant][(city+1) % self.N]] \
                                += 1/best_length
                            self.tau.at[tours[ant][(city+1) % self.N], tours[ant][city]] \
                                += 1/best_length

                def draw_shortest_path(self, shortest_path):
                    """Draw in green the shortest path from all iterations."""
                    for city in range(self.N):
                        self.draw_path(shortest_path[city],
                                       shortest_path[(city+1) % self.N],
                                       'seagreen', 0.6)

                def distance(self, city_1, city_2):
                    """Calculate distance between two cities based on their id numbers."""
                    x_1 = self.x[city_1 - 1]
                    x_2 = self.x[city_2 - 1]
                    y_1 = self.y[city_1 - 1]
                    y_2 = self.y[city_2 - 1]
                    return math.sqrt(pow(x_1 - x_2, 2) + pow(y_1 - y_2, 2))

                def draw_path(self, city_1, city_2, line_color, pheromone):
                    """Draw a line between cities, thickness based on pheromone amount."""
                    x_1 = self.x[city_1 - 1]
                    x_2 = self.x[city_2 - 1]
                    y_1 = self.y[city_1 - 1]
                    y_2 = self.y[city_2 - 1]
                    self.ax.plot([x_1, x_2], [y_1, y_2],
                                 color=line_color, linewidth=(10*pheromone**2+0.1))
>>>>>>> 7169d9ccda817c6b94d244f0627b2f5b6c3b1034
        </code>
      </pre>
    </div>
    <div class="flex-right">
      <pre class="line-numbers">
<<<<<<< HEAD
        <code class="language-python">if __name__ == '__main__':
            # Initialize the population and load a specific dataset to approximate
            p = Population()
            p.load_data(19)
            iterations = 0
            # State wanted accuracy (difference between best parent and best offspring)
            eps = 1e-3
            while(True):
                # Perform mutation, combination and reduction to the original size
                offspring = p.mutate()
                best_parent = p.evaluate(p.population, best=True)
                best_offspring = p.evaluate(offspring, best=True)
                p.population = p.population + offspring
                p.population = [p.population[i] for i in p.evaluate(
                    p.population, indices=True)[:p.pop_size]]
                iterations += 1

                # This difference of best individuals marks our stop condition
                if abs(best_parent - best_offspring) < eps:
                    break
            print(f'Condition met in {iterations} iterations')

            # The best estimated coefficients
            a, b, c = p.population[0][:3]
            print(f'Estimated values:\na = {a}\nb = {b}\nc = {c}')

            # Present the results with a graph
            p.plot_results(a, b, c)
=======
        <code class="language-python">if __name__ == "__main__":
              # Create an ant colony and prepare the environment
              ant_colony = AntColonySystem(20, alpha=0.5)
              ant_colony.open_map(3)
              ant_colony.prepare_distance_table()
              ant_colony.prepare_pheromone_table()
              ant_colony.set_hometowns()
              ant_colony.draw_map()

              # Number of iterations (repeated tour taking)
              TOTAL_ITERATIONS = 50

              # Set the shortest path length holder variable
              shortest_path_length = sum(ant_colony.d.unstack())

              # Drop all ants on the map for the given number of times
              for iteration in range(TOTAL_ITERATIONS):
                  # Create an internal table of ants with memory of visited citites
                  ant_colony.spawn_ants()

                  # Set up a dictionary of cities visited by each ant in order
                  tours = {ant: [ant_colony.ants.loc[ant, 'Current']]
                           for ant in ant_colony.ants.index}

                  # Until there is at least one unvisited city by at least by one ant
                  while (~ant_colony.ants_tour_complete()):

                      # Prepare a decision table with probabilities of chosing cities
                      ant_colony.calculate_decision_table()

                      # Selecting next cities to travel to
                      next_cities = ant_colony.choose_next_cities()

                      # Travelling to the chosen city
                      for ant in ant_colony.ants.index:
                          current = ant_colony.ants.loc[ant, 'Current']

                          # Calculate distanace, add to tour length
                          ant_colony.ants.loc[ant, 'TourLength'] \
                              += ant_colony.distance(current, next_cities[ant])

                          # Plot the travel from current city to the next one on a map
                          ant_colony.draw_path(current, next_cities[ant], 'lightgrey',
                                               ant_colony.tau.at[current,
                                                                 next_cities[ant]])

                          # Set new city as the current city, add to tour
                          ant_colony.ants.loc[ant, 'Current'] = next_cities[ant]
                          tours[ant].append(next_cities[ant])

                          # Update visited cities
                          ant_colony.ants.loc[ant,
                                              ant_colony.ants.loc[ant, 'Current']] = True

                  # After the complete tour go back to respective hometowns
                  ant_colony.finish_in_hometowns()

                  # Evaporate some and deposit new pheromones
                  ant_colony.update_pheromones(tours, elite_ants_count=6)

                  # Evaluate shortest travel distance
                  for ant in tours:
                      if ant_colony.ants.loc[ant, 'TourLength'] <= \
                              shortest_path_length:
                          shortest_path_length = ant_colony.ants.loc[ant, 'TourLength']
                          shortest_path = tours[ant]

                  # Print the shortest distance in this iteration
                  iter_best = min(ant_colony.ants['TourLength'])
                  print(f'Shortest path length in iteration {iteration+1}: {iter_best}')

              # Draw the shortest path on the map
              ant_colony.draw_shortest_path(shortest_path)

              # Output the final result
              print(f'Shortest path: {shortest_path}\nLength: {shortest_path_length}\n')
              plt.show()
>>>>>>> 7169d9ccda817c6b94d244f0627b2f5b6c3b1034
        </code>
      </pre>
    </div>
  </div>
    </div>
    <script src="prism.js"></script>
  </body>
</html>
